#!/bin/python3
import yaml
import json
import sys
import subprocess
import argparse
import os
import re
import shutil

class AppManager:
    def __init__(self):
        self.midclt_path = self._get_midclt_path()
    
    def _get_midclt_path(self):
        midclt_path = shutil.which("midclt")
        if not midclt_path:
            print("Error: midclt command not found in PATH.")
            sys.exit(1)
        return midclt_path
    
    def query_apps(self, params):
        proc = subprocess.run([self.midclt_path, "call", "app.query", params], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        if proc.returncode != 0:
            print(f"Error querying apps: {proc.stderr.decode()}")
            sys.exit(1)
        try:
            return json.loads(proc.stdout)
        except json.JSONDecodeError as e:
            print(f"Error parsing JSON response: {e}")
            sys.exit(1)
    
    def check_app_exists(self, app_name):
        params = f'[["custom_app","=",true],["name","=","{app_name}"]]'
        result = self.query_apps(params)
        return len(result) > 0
    
    def validate_app_name(self, app_name):
        if not app_name or not isinstance(app_name, str):
            print("Error: App name must be a non-empty string.")
            sys.exit(1)
        if not re.match(r'^[a-z]([-a-z0-9]*[a-z0-9])?$', app_name) or len(app_name) > 40:
            print("Error: App name must be 1-40 characters long, start with a letter, end with alphanumeric, and contain only lowercase letters, numbers and hyphens (not at start/end).")
            sys.exit(1)

    def find_compose_file(self, file_path):
        if not file_path:
            candidates = ['compose.yml', 'compose.yaml', 'docker-compose.yml', 'docker-compose.yaml']
            found = [f for f in candidates if os.path.exists(f)]
            if not found:
                print("Error: No compose file found. Use --file to specify one.")
                sys.exit(1)
            elif len(found) > 1:
                print(f"Error: Multiple compose files found: {', '.join(found)}. Use --file to specify one.")
                sys.exit(1)
            file_path = found[0]
        return file_path

    def read_compose_file(self, file_path):
        file_path = self.find_compose_file(file_path)
        abs_path = os.path.abspath(file_path)
        try:
            with open(abs_path, 'r') as file:
                compose_file = yaml.safe_load(file)
        except FileNotFoundError:
            print(f"Error: Compose file '{file_path}' not found.")
            sys.exit(1)
        except yaml.YAMLError as e:
            print(f"Error: Invalid YAML in compose file: {e}")
            sys.exit(1)
        except Exception as e:
            print(f"Error reading compose file: {e}")
            sys.exit(1)
        return yaml.dump(compose_file)

class JobExecutor:
    def execute_job_and_report_progress(self, cmd_array, midclt_path):
        proc_cmd = subprocess.run(cmd_array, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        if proc_cmd.returncode != 0:
            print(f"Error executing command: {proc_cmd.stderr.decode()}")
            sys.exit(1)

        try:
            job_id = proc_cmd.stdout.decode().strip()
        except UnicodeDecodeError as e:
            print(f"Error decoding command output: {e}")
            sys.exit(1)

        job_percent_complete = 0
        job_state = "RUNNING"

        while job_percent_complete < 100 and job_state != "FAILED":
            proc_wait = subprocess.run([midclt_path, "call", "core.get_jobs", f'[["id","=",{job_id}]]'], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            if proc_wait.returncode != 0:
                print(f"Error getting job status: {proc_wait.stderr.decode()}")
                break

            try:
                wait_result = json.loads(proc_wait.stdout)
                if not wait_result:
                    print("Error: No job found")
                    break
                job_percent_complete = wait_result[0]['progress']['percent']
                job_state = wait_result[0]['state']
                print(f"\r\x1b[K{wait_result[0]['progress']['description']} (progress: {wait_result[0]['progress']['percent']}% -> {wait_result[0]['state']})", end="")
            except (json.JSONDecodeError, KeyError, IndexError) as e:
                print(f"Error parsing job status: {e}")
                break

        print()

class CommandHandler:
    def __init__(self):
        self.app_manager = AppManager()
        self.job_executor = JobExecutor()

    def list_apps(self):
        params = '[["custom_app","=",true]]'
        app_list = self.app_manager.query_apps(params)
        if len(app_list) > 0:
            print("Deployed Custom Apps:")
            for app in app_list:
                print(f'  {app["name"]:40s} {app["state"]:7s}')
        else:
            print("No deployed custom apps found.")

    def inspect_app(self, app_name, compact):
        params = f'[["custom_app","=",true],["name","=","{app_name}"]]'
        app_details = self.app_manager.query_apps(params)
        if not app_details:
            print(f"Error: App '{app_name}' not found.")
            sys.exit(1)
        if compact:
            print(json.dumps(app_details[0]))
        else:
            print(json.dumps(app_details[0], indent=4))

    def create_app(self, app_name, file_path):
        self.app_manager.validate_app_name(app_name)

        if self.app_manager.check_app_exists(app_name):
            print(f"Error: App '{app_name}' already exists.")
            sys.exit(1)

        compose_file_str = self.app_manager.read_compose_file(file_path)
        params = json.dumps({
            "app_name": app_name,
            "custom_app": True,
            "custom_compose_config_string": compose_file_str
        })
        self.job_executor.execute_job_and_report_progress([self.app_manager.midclt_path, "call", "app.create", params], self.app_manager.midclt_path)

    def update_app(self, app_name, file_path):
        if not self.app_manager.check_app_exists(app_name):
            print(f"Error: App '{app_name}' does not exist.")
            sys.exit(1)

        compose_file_str = self.app_manager.read_compose_file(file_path)
        params = json.dumps({"custom_compose_config_string": compose_file_str})
        self.job_executor.execute_job_and_report_progress([self.app_manager.midclt_path, "call", "app.update", app_name, params], self.app_manager.midclt_path)

    def execute_app_command(self, app_name, command):
        if not self.app_manager.check_app_exists(app_name):
            print(f"Error: App '{app_name}' does not exist.")
            sys.exit(1)
        action = f"app.{command}"
        self.job_executor.execute_job_and_report_progress([self.app_manager.midclt_path, "call", action, app_name], self.app_manager.midclt_path)

    def execute_compose_command(self, app_name, file_path, unknown_args):
        compose_file = self.app_manager.find_compose_file(file_path)
        cmd = ['docker', 'compose', '-f', compose_file, '-p', f'ix-{app_name}' ] + unknown_args
        print(cmd)
        subprocess.run(cmd)

class ArgumentParser:
    @staticmethod
    def configure_argparser():
        parser = argparse.ArgumentParser(description='TrueNAS Custom App Control')
        subparsers = parser.add_subparsers(dest='command', help='Available commands')

        create_parser = subparsers.add_parser('create', help='Create a new app')
        create_parser.add_argument('--file', '-f', help='Docker compose file')
        create_parser.add_argument('app_name', nargs='?', help='Name of the app (defaults to current directory name)')

        update_parser = subparsers.add_parser('update', help='Update an existing app')
        update_parser.add_argument('--file', '-f', help='Docker compose file')
        update_parser.add_argument('app_name', nargs='?', help='Name of the app (defaults to current directory name)')

        up_parser = subparsers.add_parser('up', help='Create a new app or update an existing app')
        up_parser.add_argument('--file', '-f', help='Docker compose file')
        up_parser.add_argument('app_name', nargs='?', help='Name of the app (defaults to current directory name)')

        delete_parser = subparsers.add_parser('delete', help='Delete an app')
        delete_parser.add_argument('app_name', nargs='?', help='Name of the app (defaults to current directory name)')

        down_parser = subparsers.add_parser('down', help='Delete an app')
        down_parser.add_argument('app_name', nargs='?', help='Name of the app (defaults to current directory name)')

        stop_parser = subparsers.add_parser('stop', help='Stop an app')
        stop_parser.add_argument('app_name', nargs='?', help='Name of the app (defaults to current directory name)')

        start_parser = subparsers.add_parser('start', help='Start an app')
        start_parser.add_argument('app_name', nargs='?', help='Name of the app (defaults to current directory name)')

        restart_parser = subparsers.add_parser('restart', help='Restart an app')
        restart_parser.add_argument('app_name', nargs='?', help='Name of the app (defaults to current directory name)')

        redeploy_parser = subparsers.add_parser('redeploy', help='Redeploy an app')
        redeploy_parser.add_argument('app_name', nargs='?', help='Name of the app (defaults to current directory name)')

        subparsers.add_parser('list', help='List all deployed custom apps')

        inspect_parser = subparsers.add_parser('inspect', help='Inspect custom app')
        inspect_parser.add_argument('--compact', '-c', action='store_true', help='Compact json output')
        inspect_parser.add_argument('app_name', nargs='?', help='Name of the app (defaults to current directory name)')

        compose_parser = subparsers.add_parser('compose', help='Delegate command to `docker compose`')
        compose_parser.add_argument('--file', '-f', help='Docker compose file')
        compose_parser.add_argument('--app_name', help='Name of the app (defaults to current directory name)')

        args, unknown_args = parser.parse_known_args()
        
        if not args.command:
            parser.print_help()
            exit(0)
        
        return args, unknown_args

def main():
    args, unknown_args = ArgumentParser.configure_argparser()
    handler = CommandHandler()
    
    # Use current directory name if app_name not provided
    if hasattr(args, 'app_name') and not args.app_name:
        args.app_name = os.path.basename(os.getcwd())
    
    if args.command == 'list':
        handler.list_apps()
    elif args.command == 'inspect':
        handler.inspect_app(args.app_name, args.compact)
    elif args.command == 'create':
        handler.create_app(args.app_name, args.file)
    elif args.command == 'update':
        handler.update_app(args.app_name, args.file)
    elif args.command == 'up':
        if not handler.app_manager.check_app_exists(args.app_name):
            handler.create_app(args.app_name, args.file)
        else:
            handler.update_app(args.app_name, args.file)
    elif args.command == 'down':
        handler.execute_app_command(args.app_name, 'delete')
    elif args.command == 'restart':
        handler.execute_app_command(args.app_name, 'stop')
        handler.execute_app_command(args.app_name, 'start')
    elif args.command == 'compose':
        handler.execute_compose_command(args.app_name, args.file, unknown_args)
    else:
        handler.execute_app_command(args.app_name, args.command)

if __name__ == "__main__":
    main()
